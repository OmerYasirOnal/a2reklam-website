---
interface Props {
  images: Array<{
    paths: {
      '480'?: string;
      '960'?: string;
      '1600'?: string;
    };
    category?: string;
    alt?: string;
  }>;
  lang?: 'tr' | 'en' | 'ar';
  category?: string;
  initialLimit?: number;
  aspectRatio?: 'square' | 'video' | 'auto';
}

const {
  images,
  lang = 'tr',
  category = '',
  initialLimit = 12,
  aspectRatio = 'square',
} = Astro.props;

const isRtl = lang === 'ar';
// Use 4:3 aspect ratio for better consistency across different image types
const aspectClass = aspectRatio === 'video' ? 'aspect-video' : aspectRatio === 'auto' ? 'aspect-auto' : 'aspect-[4/3]';

// Translations
const translations = {
  tr: {
    loadMore: 'Daha Fazla Yükle',
    close: 'Kapat',
    previous: 'Önceki',
    next: 'Sonraki',
    of: ' / ',
    imageViewer: 'Görsel Görüntüleyici',
    imageOf: 'Görsel',
  },
  en: {
    loadMore: 'Load More',
    close: 'Close',
    previous: 'Previous',
    next: 'Next',
    of: ' / ',
    imageViewer: 'Image Viewer',
    imageOf: 'Image',
  },
  ar: {
    loadMore: 'المزيد',
    close: 'إغلاق',
    previous: 'السابق',
    next: 'التالي',
    of: ' / ',
    imageViewer: 'عارض الصور',
    imageOf: 'صورة',
  },
};

const t = translations[lang];
const hasMore = images.length > initialLimit;
const visibleImages = images.slice(0, initialLimit);
const remainingCount = images.length - initialLimit;
---

<div class="not-prose gallery-container">
  <div
    id="gallery-grid"
    class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"
    data-total={images.length}
    data-limit={initialLimit}
  >
    {visibleImages.map((img, idx) => {
      const src480 = img.paths?.['480'] || img.paths?.['960'] || '';
      const src960 = img.paths?.['960'] || img.paths?.['1600'] || '';
      const src1600 = img.paths?.['1600'] || img.paths?.['960'] || '';
      const alt = img.alt || `Gallery image ${idx + 1}`;
      const srcset = src480 && src960 && src1600
        ? `${src480} 480w, ${src960} 960w, ${src1600} 1600w`
        : undefined;

      return (
        <button
          type="button"
          class="gallery-item group relative overflow-hidden rounded-xl bg-surface border border-white/5 hover:border-primary/50 transition-all duration-300 cursor-pointer focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-secondary"
          data-index={idx}
          data-full-src={src1600}
          data-category={img.category || category}
          aria-label={`${t.imageOf} ${idx + 1}: ${alt}`}
        >
          <div class={`${aspectClass} overflow-hidden`}>
            <img
              src={src480 || src960}
              srcset={srcset}
              sizes="(max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
              alt={alt}
              loading="lazy"
              decoding="async"
              width="480"
              height={aspectRatio === 'video' ? '270' : aspectRatio === 'auto' ? undefined : '360'}
              class="w-full h-full object-cover group-hover:scale-110 transition-transform duration-500"
            />
          </div>
          <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
          <div class="absolute inset-0 ring-1 ring-inset ring-white/10 group-hover:ring-primary/50 transition-all rounded-xl pointer-events-none"></div>
        </button>
      );
    })}
  </div>

  {hasMore && (
    <div class="text-center mt-8">
      <button
        type="button"
        id="load-more-btn"
        class="btn btn-secondary px-8 py-3"
        data-remaining={remainingCount}
      >
        {t.loadMore} ({remainingCount})
      </button>
    </div>
  )}

  <!-- Lightbox Modal - WAI-ARIA Compliant -->
  <div
    id="lightbox-modal"
    class="fixed inset-0 z-[100] bg-black/95 hidden items-center justify-center p-4"
    role="dialog"
    aria-modal="true"
    aria-labelledby="lightbox-title"
    data-rtl={isRtl ? 'true' : 'false'}
  >
    <!-- Screen reader only title -->
    <h2 id="lightbox-title" class="sr-only">{t.imageViewer}</h2>

    <!-- Visually hidden close button for accessibility/focus trap (required for WAI-ARIA) -->
    <button
      type="button"
      id="lightbox-close"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:right-4 focus:p-2 focus:bg-black/70 focus:text-white focus:rounded-lg focus:outline-none focus:ring-2 focus:ring-primary z-[110]"
      aria-label={t.close}
    >
      {t.close}
    </button>

    <div class="relative max-w-[95vw] max-h-[95vh] flex items-center justify-center p-4 md:p-8" id="lightbox-image-container">
      <img
        id="lightbox-img"
        src=""
        alt=""
        class="max-w-full max-h-[85vh] w-auto h-auto object-contain shadow-2xl rounded-lg transition-opacity duration-300 select-none"
        loading="eager"
        draggable="false"
      />
      
      <!-- Counter + Hint overlay - Positioned lower with safe-area support -->
      <div
        id="lightbox-hint"
        class="absolute left-1/2 -translate-x-1/2 text-white text-sm bg-black/80 px-5 py-3 rounded-full backdrop-blur-sm border border-white/10 flex flex-col items-center gap-1"
        style="bottom: max(0.75rem, calc(env(safe-area-inset-bottom, 0) + 0.5rem));"
        aria-live="polite"
        aria-atomic="true"
      >
        <span class="font-medium">
          <span id="lightbox-current">1</span>{t.of}<span id="lightbox-total">{images.length}</span>
        </span>
        <!-- Desktop hint -->
        <span class="hidden md:block text-xs text-gray-300 opacity-80">
          {lang === 'ar' ? 'استخدم ← → • Esc للإغلاق' : lang === 'en' ? 'Use ← → keys • Esc to close' : '← → tuşları • Esc kapat'}
        </span>
        <!-- Mobile hint -->
        <span class="block md:hidden text-xs text-gray-300 opacity-80">
          {lang === 'ar' ? 'اسحب يمين/يسار • انقر خارجاً للإغلاق' : lang === 'en' ? 'Swipe left/right • Tap outside to close' : 'Sağ/sol kaydır • Kapatmak için dışarı dokun'}
        </span>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ allImages: images, totalImages: images.length, initialLimit, aspectRatio, t, isRtl, category }}>
  (function() {
    const container = document.currentScript?.previousElementSibling?.closest('.gallery-container') || document.querySelector('.gallery-container');
    if (!container) return;

    const galleryItems = container.querySelectorAll('.gallery-item');
    const lightbox = container.querySelector('#lightbox-modal');
    const lightboxImg = container.querySelector('#lightbox-img');
    const lightboxClose = container.querySelector('#lightbox-close');
    const lightboxCurrent = container.querySelector('#lightbox-current');
    const lightboxTotal = container.querySelector('#lightbox-total');
    const loadMoreBtn = container.querySelector('#load-more-btn');
    const galleryGrid = container.querySelector('#gallery-grid');
    const lightboxImageContainer = container.querySelector('#lightbox-image-container');

    let currentIndex = 0;
    let lastFocusedElement = null;
    const allImagesData = allImages;

    // Pointer-based gesture state (unified touch/mouse handling)
    let pointerId = null;
    let startX = 0;
    let startY = 0;
    let lastX = 0;
    let lastY = 0;
    let isDragging = false;
    let lastSwipeTime = 0;
    const MIN_SWIPE_X = 40; // Minimum horizontal distance for swipe
    const MAX_SWIPE_Y = 110; // Maximum vertical distance allowed
    const SWIPE_COOLDOWN = 350; // ms to prevent click-after-swipe

    // Get all focusable elements within a container
    function getFocusableElements(el) {
      return el.querySelectorAll(
        'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
      );
    }

    // Open lightbox with accessibility features
    function openLightbox(index, triggerElement) {
      currentIndex = index;
      lastFocusedElement = triggerElement || document.activeElement;

      updateLightboxImage();
      lightbox?.classList.remove('hidden');
      lightbox?.classList.add('flex');
      document.body.style.overflow = 'hidden';

      // Make background content inert
      const mainContent = document.getElementById('main-content');
      if (mainContent) {
        mainContent.setAttribute('inert', '');
      }

      // Focus first focusable element (close button)
      lightboxClose?.focus();
    }

    // Update lightbox image
    function updateLightboxImage() {
      if (currentIndex < 0 || currentIndex >= totalImages) {
        currentIndex = Math.max(0, Math.min(currentIndex, totalImages - 1));
      }

      const imgData = allImagesData[currentIndex];
      if (!imgData || !lightboxImg) return;

      const src1600 = imgData.paths?.['1600'] || imgData.paths?.['960'] || imgData.paths?.['480'] || '';
      if (src1600) {
        lightboxImg.src = src1600;
        lightboxImg.alt = imgData.alt || `Gallery image ${currentIndex + 1}`;
      }

      if (lightboxCurrent) lightboxCurrent.textContent = String(currentIndex + 1);
      if (lightboxTotal) lightboxTotal.textContent = String(totalImages);
    }

    // Close lightbox with focus return
    function closeLightbox() {
      lightbox?.classList.add('hidden');
      lightbox?.classList.remove('flex');
      document.body.style.overflow = '';

      // Remove inert from background
      const mainContent = document.getElementById('main-content');
      if (mainContent) {
        mainContent.removeAttribute('inert');
      }

      // Return focus to trigger element
      if (lastFocusedElement && lastFocusedElement.focus) {
        lastFocusedElement.focus();
      }
      lastFocusedElement = null;
    }

    // Navigate with bounds checking
    function navigate(direction) {
      if (totalImages <= 0) return;

      if (direction === 'prev') {
        currentIndex = currentIndex > 0 ? currentIndex - 1 : totalImages - 1;
      } else {
        currentIndex = currentIndex < totalImages - 1 ? currentIndex + 1 : 0;
      }
      updateLightboxImage();
    }

    // Event listeners for gallery items
    galleryItems.forEach((item) => {
      item.addEventListener('click', function() {
        const actualIdx = Array.from(container.querySelectorAll('.gallery-item')).indexOf(this);
        openLightbox(actualIdx, this);
      });
    });

    // Lightbox close button (the visually hidden accessible one)
    lightboxClose?.addEventListener('click', (e) => {
      e.stopPropagation();
      closeLightbox();
    });

    // Close on backdrop click (with swipe cooldown protection)
    lightbox?.addEventListener('click', (e) => {
      // Prevent click-after-swipe closure
      const timeSinceSwipe = Date.now() - lastSwipeTime;
      if (timeSinceSwipe < SWIPE_COOLDOWN) {
        return;
      }

      // Close if clicking on the backdrop (the lightbox itself) but not on the image or hint
      const clickedElement = e.target;
      if (clickedElement === lightbox || clickedElement === lightboxImageContainer) {
        closeLightbox();
      }
    });

    // Pointer-based gesture navigation (unified touch/mouse handling)
    if (lightboxImageContainer) {
      lightboxImageContainer.addEventListener('pointerdown', (e) => {
        // Only handle primary pointer (first touch or left mouse button)
        if (pointerId !== null) return;

        pointerId = e.pointerId;
        startX = e.clientX;
        startY = e.clientY;
        lastX = e.clientX;
        lastY = e.clientY;
        isDragging = false;

        // Capture pointer for smooth tracking
        lightboxImageContainer.setPointerCapture(e.pointerId);
      });

      lightboxImageContainer.addEventListener('pointermove', (e) => {
        if (e.pointerId !== pointerId) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        // Mark as dragging if moved significantly
        if (!isDragging && (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3)) {
          isDragging = true;
        }

        lastX = e.clientX;
        lastY = e.clientY;
      });

      lightboxImageContainer.addEventListener('pointerup', (e) => {
        if (e.pointerId !== pointerId) return;

        const deltaX = lastX - startX;
        const deltaY = Math.abs(lastY - startY);

        // Check if this was a swipe gesture
        if (isDragging && Math.abs(deltaX) > MIN_SWIPE_X && deltaY < MAX_SWIPE_Y) {
          const effectiveIsRtl = lightbox?.dataset.rtl === 'true';

          if (deltaX > 0) {
            // Swipe right
            navigate(effectiveIsRtl ? 'next' : 'prev');
          } else {
            // Swipe left
            navigate(effectiveIsRtl ? 'prev' : 'next');
          }

          // Record swipe time to prevent immediate click-close
          lastSwipeTime = Date.now();
        }

        // Reset pointer state
        pointerId = null;
        isDragging = false;

        if (lightboxImageContainer.hasPointerCapture(e.pointerId)) {
          lightboxImageContainer.releasePointerCapture(e.pointerId);
        }
      });

      lightboxImageContainer.addEventListener('pointercancel', (e) => {
        if (e.pointerId !== pointerId) return;

        // Reset on cancel (e.g., gesture interrupted)
        pointerId = null;
        isDragging = false;
      });
    }

    // Keyboard navigation with focus trap
    document.addEventListener('keydown', (e) => {
      if (lightbox?.classList.contains('hidden')) return;

      const effectiveIsRtl = lightbox?.dataset.rtl === 'true';

      if (e.key === 'Escape') {
        e.preventDefault();
        closeLightbox();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        navigate(effectiveIsRtl ? 'next' : 'prev');
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        navigate(effectiveIsRtl ? 'prev' : 'next');
      } else if (e.key === 'Tab') {
        // Focus trap implementation
        const focusables = getFocusableElements(lightbox);
        if (focusables.length === 0) return;

        const first = focusables[0];
        const last = focusables[focusables.length - 1];

        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    });

    // Load more functionality
    if (loadMoreBtn && galleryGrid) {
      const limit = parseInt(galleryGrid.getAttribute('data-limit') || '12');
      const total = parseInt(galleryGrid.getAttribute('data-total') || String(totalImages));
      let currentLoaded = initialLimit;

      loadMoreBtn.addEventListener('click', () => {
        const remaining = total - currentLoaded;
        const toLoad = Math.min(limit, remaining);

        if (toLoad <= 0) {
          if (loadMoreBtn) loadMoreBtn.style.display = 'none';
          return;
        }

        // Create and append new items
        for (let i = currentLoaded; i < currentLoaded + toLoad && i < allImagesData.length; i++) {
          const imgData = allImagesData[i];
          const src480 = imgData.paths?.['480'] || imgData.paths?.['960'] || '';
          const src960 = imgData.paths?.['960'] || imgData.paths?.['1600'] || '';
          const src1600 = imgData.paths?.['1600'] || imgData.paths?.['960'] || '';
          const alt = imgData.alt || `Gallery image ${i + 1}`;
          const srcset = src480 && src960 && src1600
            ? `${src480} 480w, ${src960} 960w, ${src1600} 1600w`
            : undefined;

          const aspectClass = aspectRatio === 'video' ? 'aspect-video' : aspectRatio === 'auto' ? 'aspect-auto' : 'aspect-[4/3]';
          const itemCategory = imgData.category || category;

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'gallery-item group relative overflow-hidden rounded-xl bg-surface border border-white/5 hover:border-primary/50 transition-all duration-300 cursor-pointer focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-secondary';
          button.setAttribute('data-index', String(i));
          button.setAttribute('data-full-src', src1600);
          button.setAttribute('data-category', itemCategory);
          button.setAttribute('aria-label', `${t.imageOf} ${i + 1}: ${alt}`);

          button.innerHTML = `
            <div class="${aspectClass} overflow-hidden bg-surface">
              <img
                src="${src480 || src960}"
                ${srcset ? `srcset="${srcset}" sizes="(max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"` : ''}
                alt="${alt}"
                loading="lazy"
                decoding="async"
                width="480"
                height="${aspectRatio === 'video' ? '270' : '360'}"
                class="w-full h-full object-cover group-hover:scale-110 transition-transform duration-500"
              />
            </div>
            <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <div class="absolute inset-0 ring-1 ring-inset ring-white/10 group-hover:ring-primary/50 transition-all rounded-xl pointer-events-none"></div>
          `;

          button.addEventListener('click', function() {
            openLightbox(i, this);
          });

          if (galleryGrid) galleryGrid.appendChild(button);
        }

        currentLoaded += toLoad;
        const remainingAfter = total - currentLoaded;

        if (remainingAfter <= 0) {
          if (loadMoreBtn) loadMoreBtn.style.display = 'none';
        } else {
          if (loadMoreBtn) loadMoreBtn.textContent = `${t.loadMore} (${remainingAfter})`;
        }
      });
    }
  })();
</script>

<style>
  /* Critical: Enable pointer events on mobile by controlling touch actions */
  #lightbox-image-container {
    touch-action: pan-y pinch-zoom;
    /* Allow vertical scroll and pinch zoom, we handle horizontal swipes */
    user-select: none;
    -webkit-user-select: none;
  }

  #lightbox-modal img {
    animation: fadeIn 0.3s ease-out;
    pointer-events: none; /* Prevent image from capturing pointer events */
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  /* Respect reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    #lightbox-modal img {
      animation: none;
    }

    .gallery-item img {
      transition: none;
    }
  }
</style>
